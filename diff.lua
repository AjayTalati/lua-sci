--------------------------------------------------------------------------------
-- Automatic differentiation module.
--
-- Copyright (C) 2011-2014 Stefano Peluchetti. All rights reserved.
--
-- Features, documentation and more: http://www.scilua.org .
--
-- This file is part of the SciLua library, which is released under the MIT 
-- license: full text in file LICENSE.TXT in the library's root folder.
--------------------------------------------------------------------------------

-- TODO: Optimized: phi, iphi, gamma, loggamma, logbeta, beta.

local ffi  = require "ffi"
local xsys = require "xsys"
local math = require "sci.math"

local type, exec = type, xsys.exec

local
abs, acos, asin, atan, atan2, ceil, cos, cosh, deg, exp, floor, fmod, frexp,
huge, ldexp, log, log10, max, min, modf, pi, pow, rad, random, randomseed, sin, 
sinh, sqrt, tan, tanh,
round, step, sign,
phi, iphi, gamma, loggamma, logbeta, beta
= xsys.from(math, [[
abs, acos, asin, atan, atan2, ceil, cos, cosh, deg, exp, floor, fmod, frexp,
huge, ldexp, log, log10, max, min, modf, pi, pow, rad, random, randomseed, sin, 
sinh, sqrt, tan, tanh,
round, step, sign,
phi, iphi, gamma, loggamma, logbeta, beta
]])

local function isn(x)
  return type(x) == "number"
end

-- Forward mode, single directional derivative ---------------------------------
local dn -- Dual number: value + adjoint value.

-- Modified from sci.math:
local dngamma, dnloggamma
do
  -- r(10).
  local gamma_r10 = 10.900511
  -- dk[0], ..., dk[10].
  local gamma_dk = ffi.new("double[11]", 
    2.48574089138753565546e-5,
    1.05142378581721974210,
    -3.45687097222016235469,
    4.51227709466894823700,
    -2.98285225323576655721,
    1.05639711577126713077,
    -1.95428773191645869583e-1,
    1.70970543404441224307e-2,
    -5.71926117404305781283e-4,
    4.63399473359905636708e-6,
    -2.71994908488607703910e-9
  )
  local gamma_c = 2*sqrt(exp(1)/pi)

  -- Lanczos approximation, see:
  -- Pugh[2004]: AN ANALYSIS OF THE LANCZOS GAMMA APPROXIMATION
  -- http://bh0.physics.ubc.ca/People/matt/Doc/ThesesOthers/Phd/pugh.pdf
  -- page 116 for optimal formula and coefficients. Theoretical accuracy of 
  -- 16 digits is likely in practice to be around 14.
  -- Domain: R except 0 and negative integers.
  dngamma = function(z)  
    -- Reflection formula to handle negative z plane.
    -- Better to branch at z < 0 as some probabilistic use cases only consider 
    -- the case z >= 0.
    if z < 0 then 
      return pi/((pi*z):sin()*dngamma(1 - z)) 
    end  
    local sum = gamma_dk[0]
    sum = sum + gamma_dk[1]/(z + 0)
    sum = sum + gamma_dk[2]/(z + 1) 
    sum = sum + gamma_dk[3]/(z + 2) 
    sum = sum + gamma_dk[4]/(z + 3) 
    sum = sum + gamma_dk[5]/(z + 4) 
    sum = sum + gamma_dk[6]/(z + 5) 
    sum = sum + gamma_dk[7]/(z + 6) 
    sum = sum + gamma_dk[8]/(z + 7) 
    sum = sum + gamma_dk[9]/(z + 8) 
    sum = sum + gamma_dk[10]/(z + 9)  
    return gamma_c*((z  + gamma_r10 - 0.5)/exp(1))^(z - 0.5)*sum
  end

  -- Returns log(abs(gamma(z))).
  -- Domain: R except 0 and negative integers.
  dnloggamma = function(z)
    if z < 0 then 
      return log(pi) - (pi*z):sin():abs():log() - dnloggamma(1 - z) 
    end  
    local sum = gamma_dk[0]
    sum = sum + gamma_dk[1]/(z + 0)
    sum = sum + gamma_dk[2]/(z + 1) 
    sum = sum + gamma_dk[3]/(z + 2) 
    sum = sum + gamma_dk[4]/(z + 3) 
    sum = sum + gamma_dk[5]/(z + 4) 
    sum = sum + gamma_dk[6]/(z + 5) 
    sum = sum + gamma_dk[7]/(z + 6) 
    sum = sum + gamma_dk[8]/(z + 7) 
    sum = sum + gamma_dk[9]/(z + 8) 
    sum = sum + gamma_dk[10]/(z + 9) 
    -- For z >= 0 gamma function is positive, no abs() required.
    return log(gamma_c) + (z - 0.5)*(z  + gamma_r10 - 0.5):log()
      - (z - 0.5) + sum:log()
  end

end

-- Domain: a > 0 and b > 0.
local function dnlogbeta(a, b)
  if a <= 0 or b <= 0 then return 0/0 end
  local lga = isn(a) and loggamma(a) or dnloggamma(a)
  local lgb = isn(b) and loggamma(b) or dnloggamma(b)
  return lga + lgb - dnloggamma(a + b)
end

-- Domain: a > 0 and b > 0.
local function dnbeta(a, b)
  return dnlogbeta(a, b):exp()
end

local function dnmax(x, y)
  x, y = dn(x), dn(y)
  if max(abs(x._v), abs(y._v)) == 1/0 then
    return x >=y and x or y
  else -- Branchless optimization.
    local z = step(y._v - x._v) -- 1 if y >= x, 0 otherwise.
    return dn(z*y._v + (1 - z)*x._v, z*y._a + (1 - z)*x._a)
  end
end

local function dnmin(x, y)
  x, y = dn(x), dn(y)
  if max(abs(x._v), abs(y._v)) == 1/0 then
    return x <= y and x or y
  else -- Branchless optimization.
    local z = step(x._v - y._v) -- 1 if x >= y, 0 otherwise.
    return dn(z*y._v + (1 - z)*x._v, z*y._a + (1 - z)*x._a)
  end
end

-- Note: dual numbers are immutable: new ones generated by operators.
local dn_mt = {
  __unm = function(x)
    return dn(-x._v, -x._a)
  end,
  __add = function(x, y) x, y = dn(x), dn(y)
    return dn(x._v + y._v, x._a + y._a)
  end,
  __sub = function(x, y) x, y = dn(x), dn(y)
    return dn(x._v - y._v, x._a - y._a)
  end,
  __mul = function(x, y) x, y = dn(x), dn(y)
    return dn(x._v*y._v, x._a*y._v + y._a*x._v)
  end,
  __div = function(x, y) x, y = dn(x), dn(y)
    return dn(x._v/y._v, (x._a*y._v - y._a*x._v)/y._v^2)
  end,
  __pow = function(x, y) -- Optimized version.
    if isn(y) then
      return dn(x._v^y, y*x._v^(y-1)*x._a)
    elseif isn(x) then
      return dn(x^y._v, x^y._v*log(x)*y._a)
    else
      return dn(x._v^y._v, x._v^y._v*(log(x._v)*y._a + y._v/x._v*x._a))
    end
  end,
  __eq = function(x, y) x, y = dn(x), dn(y)
    return x._v == y._v
  end,
  __lt = function(x, y) x, y = dn(x), dn(y)
    return x._v < y._v
  end,
  __le = function(x, y) x, y = dn(x), dn(y)
    return x._v <= y._v
  end,
  __tostring = function(x)
    local asign = x._a < 0 and "" or "+" -- Handles nan as well.
    return tostring(x._v)..asign..tostring(x._a).."d"
  end,
  
  copy = function(x)
    return dn(x)
  end,
  
  val = function(x)
    return x._v
  end,
  adj = function(x)
    return x._a
  end,
  
  exp   = function(x) return dn(exp(x._v),   x._a*exp(x._v)) end,
  log   = function(x) return dn(log(x._v),   x._a/x._v) end,
  sin   = function(x) return dn(sin(x._v),   x._a*cos(x._v)) end,
  cos   = function(x) return dn(cos(x._v),   x._a*(-sin(x._v))) end,
  sqrt  = function(x) return dn(sqrt(x._v),  x._a/(2*sqrt(x._v))) end,
  abs   = function(x) return dn(abs(x._v),   x._a*sign(x._v)) end,
  -- Stick to dn type to improve type stability:
  floor = function(x) return dn(floor(x._v), 0) end,
  ceil  = function(x) return dn(ceil(x._v),  0) end,
  
  round = function(x) return dn(round(x._v), 0) end,
  step  = function(x) return dn(step(x._v),  0) end,
  sign  = function(x) return dn(sign(x._v),  0) end,
  
  -- TODO: Specific optimized versions:
  gamma    = function(x) return dngamma(x) end,
  loggamma = function(x) return dnloggamma(x) end,
  
  beta     = function(x, y) return dnbeta(x, y) end,
  logbeta  = function(x, y) return dnlogbeta(x, y) end,

  max   = dnmax,
  min   = dnmin,
}
dn_mt.__index = dn_mt

-- Note: _v comes first. This allows to construct a dual number from a number
-- using dn(number) => adjoint part correctly initialized to 0.
dn = ffi.metatype("struct { double _v, _a; }", dn_mt)

local algdn, elwdn

local function valgradf(f, n)
  algdn = algdn or require("sci.alg").typeof(dn, true)
  elwdn = elwdn or require("sci.alg").elwf(dn)
  local xd = algdn.vec(n)
  return function(x, grad)
  local val
    for i=1,n do
      xd:set(elwdn(x))
      xd[i] = xd[i] + dn(0, 1)
      local vd = dn(f(xd))
      val = vd:val()
      grad[i] = vd:adj()
    end
    return val
  end
end

return {
  dn       = dn,
  valgradf = valgradf,
}
